{"ast":null,"code":"\"use strict\";\n/*\n * (C) Copyright 2017-2020 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nexports.__esModule = true;\n\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\n\nvar platform = require(\"platform\");\n/**\n * Easy recording of [[Stream]] objects straightaway from the browser. Initialized with [[OpenVidu.initLocalRecorder]] method\n *\n * > WARNINGS:\n * - Performing browser local recording of **remote streams** may cause some troubles. A long waiting time may be required after calling _LocalRecorder.stop()_ in this case\n * - Only Chrome and Firefox support local stream recording\n */\n\n\nvar LocalRecorder =\n/** @class */\nfunction () {\n  /**\n   * @hidden\n   */\n  function LocalRecorder(stream) {\n    this.stream = stream;\n    this.chunks = [];\n    this.connectionId = !!this.stream.connection ? this.stream.connection.connectionId : 'default-connection';\n    this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n    this.state = LocalRecorderState_1.LocalRecorderState.READY;\n  }\n  /**\n   * Starts the recording of the Stream. [[state]] property must be `READY`. After method succeeds is set to `RECORDING`\n   *\n   * @param mimeType The [MediaRecorder.mimeType](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/mimeType) to be used to record this Stream.\n   * Make sure the platform supports it or the promise will return an error. If this parameter is not provided, the MediaRecorder will use the default codecs available in the platform\n   *\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.record = function (mimeType) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (typeof MediaRecorder === 'undefined') {\n          console.error('MediaRecorder not supported on your browser. See compatibility in https://caniuse.com/#search=MediaRecorder');\n          throw Error('MediaRecorder not supported on your browser. See compatibility in https://caniuse.com/#search=MediaRecorder');\n        }\n\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n          throw Error('\\'LocalRecord.record()\\' needs \\'LocalRecord.state\\' to be \\'READY\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.clean()\\' or init a new LocalRecorder before');\n        }\n\n        console.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n        var options = {};\n\n        if (typeof MediaRecorder.isTypeSupported === 'function') {\n          if (!!mimeType) {\n            if (!MediaRecorder.isTypeSupported(mimeType)) {\n              reject(new Error('mimeType \"' + mimeType + '\" is not supported'));\n            }\n\n            options = {\n              mimeType: mimeType\n            };\n          } else {\n            console.log('No mimeType parameter provided. Using default codecs');\n          }\n        } else {\n          console.warn('MediaRecorder#isTypeSupported is not supported. Using default codecs');\n        }\n\n        _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n\n        _this.mediaRecorder.start(10);\n      } catch (err) {\n        reject(err);\n      }\n\n      _this.mediaRecorder.ondataavailable = function (e) {\n        _this.chunks.push(e.data);\n      };\n\n      _this.mediaRecorder.onerror = function (e) {\n        console.error('MediaRecorder error: ', e);\n      };\n\n      _this.mediaRecorder.onstart = function () {\n        console.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onstop = function () {\n        _this.onStopDefault();\n      };\n\n      _this.mediaRecorder.onpause = function () {\n        console.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onresume = function () {\n        console.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n      };\n\n      _this.mediaRecorder.onwarning = function (e) {\n        console.log('MediaRecorder warning: ' + e);\n      };\n\n      _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      resolve();\n    });\n  };\n  /**\n   * Ends the recording of the Stream. [[state]] property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.stop = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n          throw Error('\\'LocalRecord.stop()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' or \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' before');\n        }\n\n        _this.mediaRecorder.onstop = function () {\n          _this.onStopDefault();\n\n          resolve();\n        };\n\n        _this.mediaRecorder.stop();\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  /**\n   * Pauses the recording of the Stream. [[state]] property must be `RECORDING`. After method succeeds is set to `PAUSED`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.pause = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n          reject(Error('\\'LocalRecord.pause()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' or \\'LocalRecorder.resume()\\' before'));\n        }\n\n        _this.mediaRecorder.pause();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n      } catch (error) {\n        reject(error);\n      }\n    });\n  };\n  /**\n   * Resumes the recording of the Stream. [[state]] property must be `PAUSED`. After method succeeds is set to `RECORDING`\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n   */\n\n\n  LocalRecorder.prototype.resume = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      try {\n        if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n          throw Error('\\'LocalRecord.resume()\\' needs \\'LocalRecord.state\\' to be \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.pause()\\' before');\n        }\n\n        _this.mediaRecorder.resume();\n\n        _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n      } catch (error) {\n        reject(error);\n      }\n    });\n  };\n  /**\n   * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.preview = function (parentElement) {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.preview()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    }\n\n    this.videoPreview = document.createElement('video');\n    this.videoPreview.id = this.id;\n    this.videoPreview.autoplay = true;\n\n    if (platform.name === 'Safari') {\n      this.videoPreview.setAttribute('playsinline', 'true');\n    }\n\n    if (typeof parentElement === 'string') {\n      var parentElementDom = document.getElementById(parentElement);\n\n      if (parentElementDom) {\n        this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n      }\n    } else {\n      this.videoPreview = parentElement.appendChild(this.videoPreview);\n    }\n\n    this.videoPreview.src = this.videoPreviewSrc;\n    return this.videoPreview;\n  };\n  /**\n   * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets [[state]] to `READY` so the recording can start again\n   */\n\n\n  LocalRecorder.prototype.clean = function () {\n    var _this = this;\n\n    var f = function f() {\n      delete _this.blob;\n      _this.chunks = [];\n      delete _this.mediaRecorder;\n      _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    };\n\n    if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n      this.stop().then(function () {\n        return f();\n      })[\"catch\"](function () {\n        return f();\n      });\n    } else {\n      f();\n    }\n  };\n  /**\n   * Downloads the recorded video through the browser. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.download = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('\\'LocalRecord.download()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before');\n    } else {\n      var a = document.createElement('a');\n      a.style.display = 'none';\n      document.body.appendChild(a);\n      var url = window.URL.createObjectURL(this.blob);\n      a.href = url;\n      a.download = this.id + '.webm';\n      a.click();\n      window.URL.revokeObjectURL(url);\n      document.body.removeChild(a);\n    }\n  };\n  /**\n   * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. [[state]] property must be `FINISHED`\n   */\n\n\n  LocalRecorder.prototype.getBlob = function () {\n    if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n      throw Error('Call \\'LocalRecord.stop()\\' before getting Blob file');\n    } else {\n      return this.blob;\n    }\n  };\n  /**\n   * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n   */\n\n\n  LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        reject(Error('\\'LocalRecord.uploadAsBinary()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_1 = new XMLHttpRequest();\n        http_1.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_1.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        http_1.onreadystatechange = function () {\n          if (http_1.readyState === 4) {\n            if (http_1.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              resolve(http_1.responseText);\n            } else {\n              reject(http_1.status);\n            }\n          }\n        };\n\n        http_1.send(_this.blob);\n      }\n    });\n  };\n  /**\n   * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n   * ```\n   * var headers = {\n   *  \"Cookie\": \"$Version=1; Skin=new;\",\n   *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n   * }\n   * ```\n   * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n   */\n\n\n  LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n        reject(Error('\\'LocalRecord.uploadAsMultipartfile()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n      } else {\n        var http_2 = new XMLHttpRequest();\n        http_2.open('POST', endpoint, true);\n\n        if (typeof headers === 'object') {\n          for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n            var key = _a[_i];\n            http_2.setRequestHeader(key, headers[key]);\n          }\n        }\n\n        var sendable = new FormData();\n        sendable.append('file', _this.blob, _this.id + '.webm');\n\n        http_2.onreadystatechange = function () {\n          if (http_2.readyState === 4) {\n            if (http_2.status.toString().charAt(0) === '2') {\n              // Success response from server (HTTP status standard: 2XX is success)\n              resolve(http_2.responseText);\n            } else {\n              reject(http_2.status);\n            }\n          }\n        };\n\n        http_2.send(sendable);\n      }\n    });\n  };\n  /* Private methods */\n\n\n  LocalRecorder.prototype.onStopDefault = function () {\n    console.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n    this.blob = new Blob(this.chunks, {\n      type: 'video/webm'\n    });\n    this.chunks = [];\n    this.videoPreviewSrc = window.URL.createObjectURL(this.blob);\n    this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n  };\n\n  return LocalRecorder;\n}();\n\nexports.LocalRecorder = LocalRecorder;","map":{"version":3,"sources":["../../src/OpenVidu/LocalRecorder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*\n * (C) Copyright 2017-2020 OpenVidu (https://openvidu.io)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nexports.__esModule = true;\nvar LocalRecorderState_1 = require(\"../OpenViduInternal/Enums/LocalRecorderState\");\nvar platform = require(\"platform\");\n/**\n * Easy recording of [[Stream]] objects straightaway from the browser. Initialized with [[OpenVidu.initLocalRecorder]] method\n *\n * > WARNINGS:\n * - Performing browser local recording of **remote streams** may cause some troubles. A long waiting time may be required after calling _LocalRecorder.stop()_ in this case\n * - Only Chrome and Firefox support local stream recording\n */\nvar LocalRecorder = /** @class */ (function () {\n    /**\n     * @hidden\n     */\n    function LocalRecorder(stream) {\n        this.stream = stream;\n        this.chunks = [];\n        this.connectionId = (!!this.stream.connection) ? this.stream.connection.connectionId : 'default-connection';\n        this.id = this.stream.streamId + '_' + this.connectionId + '_localrecord';\n        this.state = LocalRecorderState_1.LocalRecorderState.READY;\n    }\n    /**\n     * Starts the recording of the Stream. [[state]] property must be `READY`. After method succeeds is set to `RECORDING`\n     *\n     * @param mimeType The [MediaRecorder.mimeType](https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/mimeType) to be used to record this Stream.\n     * Make sure the platform supports it or the promise will return an error. If this parameter is not provided, the MediaRecorder will use the default codecs available in the platform\n     *\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully started and rejected with an Error object if not\n     */\n    LocalRecorder.prototype.record = function (mimeType) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                if (typeof MediaRecorder === 'undefined') {\n                    console.error('MediaRecorder not supported on your browser. See compatibility in https://caniuse.com/#search=MediaRecorder');\n                    throw (Error('MediaRecorder not supported on your browser. See compatibility in https://caniuse.com/#search=MediaRecorder'));\n                }\n                if (_this.state !== LocalRecorderState_1.LocalRecorderState.READY) {\n                    throw (Error('\\'LocalRecord.record()\\' needs \\'LocalRecord.state\\' to be \\'READY\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.clean()\\' or init a new LocalRecorder before'));\n                }\n                console.log(\"Starting local recording of stream '\" + _this.stream.streamId + \"' of connection '\" + _this.connectionId + \"'\");\n                var options = {};\n                if (typeof MediaRecorder.isTypeSupported === 'function') {\n                    if (!!mimeType) {\n                        if (!MediaRecorder.isTypeSupported(mimeType)) {\n                            reject(new Error('mimeType \"' + mimeType + '\" is not supported'));\n                        }\n                        options = { mimeType: mimeType };\n                    }\n                    else {\n                        console.log('No mimeType parameter provided. Using default codecs');\n                    }\n                }\n                else {\n                    console.warn('MediaRecorder#isTypeSupported is not supported. Using default codecs');\n                }\n                _this.mediaRecorder = new MediaRecorder(_this.stream.getMediaStream(), options);\n                _this.mediaRecorder.start(10);\n            }\n            catch (err) {\n                reject(err);\n            }\n            _this.mediaRecorder.ondataavailable = function (e) {\n                _this.chunks.push(e.data);\n            };\n            _this.mediaRecorder.onerror = function (e) {\n                console.error('MediaRecorder error: ', e);\n            };\n            _this.mediaRecorder.onstart = function () {\n                console.log('MediaRecorder started (state=' + _this.mediaRecorder.state + ')');\n            };\n            _this.mediaRecorder.onstop = function () {\n                _this.onStopDefault();\n            };\n            _this.mediaRecorder.onpause = function () {\n                console.log('MediaRecorder paused (state=' + _this.mediaRecorder.state + ')');\n            };\n            _this.mediaRecorder.onresume = function () {\n                console.log('MediaRecorder resumed (state=' + _this.mediaRecorder.state + ')');\n            };\n            _this.mediaRecorder.onwarning = function (e) {\n                console.log('MediaRecorder warning: ' + e);\n            };\n            _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n            resolve();\n        });\n    };\n    /**\n     * Ends the recording of the Stream. [[state]] property must be `RECORDING` or `PAUSED`. After method succeeds is set to `FINISHED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording successfully stopped and rejected with an Error object if not\n     */\n    LocalRecorder.prototype.stop = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                if (_this.state === LocalRecorderState_1.LocalRecorderState.READY || _this.state === LocalRecorderState_1.LocalRecorderState.FINISHED) {\n                    throw (Error('\\'LocalRecord.stop()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' or \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' before'));\n                }\n                _this.mediaRecorder.onstop = function () {\n                    _this.onStopDefault();\n                    resolve();\n                };\n                _this.mediaRecorder.stop();\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    };\n    /**\n     * Pauses the recording of the Stream. [[state]] property must be `RECORDING`. After method succeeds is set to `PAUSED`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully paused and rejected with an Error object if not\n     */\n    LocalRecorder.prototype.pause = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                if (_this.state !== LocalRecorderState_1.LocalRecorderState.RECORDING) {\n                    reject(Error('\\'LocalRecord.pause()\\' needs \\'LocalRecord.state\\' to be \\'RECORDING\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.start()\\' or \\'LocalRecorder.resume()\\' before'));\n                }\n                _this.mediaRecorder.pause();\n                _this.state = LocalRecorderState_1.LocalRecorderState.PAUSED;\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    };\n    /**\n     * Resumes the recording of the Stream. [[state]] property must be `PAUSED`. After method succeeds is set to `RECORDING`\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved if the recording was successfully resumed and rejected with an Error object if not\n     */\n    LocalRecorder.prototype.resume = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            try {\n                if (_this.state !== LocalRecorderState_1.LocalRecorderState.PAUSED) {\n                    throw (Error('\\'LocalRecord.resume()\\' needs \\'LocalRecord.state\\' to be \\'PAUSED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.pause()\\' before'));\n                }\n                _this.mediaRecorder.resume();\n                _this.state = LocalRecorderState_1.LocalRecorderState.RECORDING;\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    };\n    /**\n     * Previews the recording, appending a new HTMLVideoElement to element with id `parentId`. [[state]] property must be `FINISHED`\n     */\n    LocalRecorder.prototype.preview = function (parentElement) {\n        if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n            throw (Error('\\'LocalRecord.preview()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n        }\n        this.videoPreview = document.createElement('video');\n        this.videoPreview.id = this.id;\n        this.videoPreview.autoplay = true;\n        if (platform.name === 'Safari') {\n            this.videoPreview.setAttribute('playsinline', 'true');\n        }\n        if (typeof parentElement === 'string') {\n            var parentElementDom = document.getElementById(parentElement);\n            if (parentElementDom) {\n                this.videoPreview = parentElementDom.appendChild(this.videoPreview);\n            }\n        }\n        else {\n            this.videoPreview = parentElement.appendChild(this.videoPreview);\n        }\n        this.videoPreview.src = this.videoPreviewSrc;\n        return this.videoPreview;\n    };\n    /**\n     * Gracefully stops and cleans the current recording (WARNING: it is completely dismissed). Sets [[state]] to `READY` so the recording can start again\n     */\n    LocalRecorder.prototype.clean = function () {\n        var _this = this;\n        var f = function () {\n            delete _this.blob;\n            _this.chunks = [];\n            delete _this.mediaRecorder;\n            _this.state = LocalRecorderState_1.LocalRecorderState.READY;\n        };\n        if (this.state === LocalRecorderState_1.LocalRecorderState.RECORDING || this.state === LocalRecorderState_1.LocalRecorderState.PAUSED) {\n            this.stop().then(function () { return f(); })[\"catch\"](function () { return f(); });\n        }\n        else {\n            f();\n        }\n    };\n    /**\n     * Downloads the recorded video through the browser. [[state]] property must be `FINISHED`\n     */\n    LocalRecorder.prototype.download = function () {\n        if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n            throw (Error('\\'LocalRecord.download()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n        }\n        else {\n            var a = document.createElement('a');\n            a.style.display = 'none';\n            document.body.appendChild(a);\n            var url = window.URL.createObjectURL(this.blob);\n            a.href = url;\n            a.download = this.id + '.webm';\n            a.click();\n            window.URL.revokeObjectURL(url);\n            document.body.removeChild(a);\n        }\n    };\n    /**\n     * Gets the raw Blob file. Methods preview, download, uploadAsBinary and uploadAsMultipartfile use this same file to perform their specific actions. [[state]] property must be `FINISHED`\n     */\n    LocalRecorder.prototype.getBlob = function () {\n        if (this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n            throw (Error('Call \\'LocalRecord.stop()\\' before getting Blob file'));\n        }\n        else {\n            return this.blob;\n        }\n    };\n    /**\n     * Uploads the recorded video as a binary file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not\n     */\n    LocalRecorder.prototype.uploadAsBinary = function (endpoint, headers) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n                reject(Error('\\'LocalRecord.uploadAsBinary()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n            }\n            else {\n                var http_1 = new XMLHttpRequest();\n                http_1.open('POST', endpoint, true);\n                if (typeof headers === 'object') {\n                    for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n                        var key = _a[_i];\n                        http_1.setRequestHeader(key, headers[key]);\n                    }\n                }\n                http_1.onreadystatechange = function () {\n                    if (http_1.readyState === 4) {\n                        if (http_1.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            resolve(http_1.responseText);\n                        }\n                        else {\n                            reject(http_1.status);\n                        }\n                    }\n                };\n                http_1.send(_this.blob);\n            }\n        });\n    };\n    /**\n     * Uploads the recorded video as a multipart file performing an HTTP/POST operation to URL `endpoint`. [[state]] property must be `FINISHED`. Optional HTTP headers can be passed as second parameter. For example:\n     * ```\n     * var headers = {\n     *  \"Cookie\": \"$Version=1; Skin=new;\",\n     *  \"Authorization\":\"Basic QWxhZGpbjpuIHNlctZQ==\"\n     * }\n     * ```\n     * @returns A Promise (to which you can optionally subscribe to) that is resolved with the `http.responseText` from server if the operation was successful and rejected with the failed `http.status` if not:\n     */\n    LocalRecorder.prototype.uploadAsMultipartfile = function (endpoint, headers) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            if (_this.state !== LocalRecorderState_1.LocalRecorderState.FINISHED) {\n                reject(Error('\\'LocalRecord.uploadAsMultipartfile()\\' needs \\'LocalRecord.state\\' to be \\'FINISHED\\' (current value: \\'' + _this.state + '\\'). Call \\'LocalRecorder.stop()\\' before'));\n            }\n            else {\n                var http_2 = new XMLHttpRequest();\n                http_2.open('POST', endpoint, true);\n                if (typeof headers === 'object') {\n                    for (var _i = 0, _a = Object.keys(headers); _i < _a.length; _i++) {\n                        var key = _a[_i];\n                        http_2.setRequestHeader(key, headers[key]);\n                    }\n                }\n                var sendable = new FormData();\n                sendable.append('file', _this.blob, _this.id + '.webm');\n                http_2.onreadystatechange = function () {\n                    if (http_2.readyState === 4) {\n                        if (http_2.status.toString().charAt(0) === '2') {\n                            // Success response from server (HTTP status standard: 2XX is success)\n                            resolve(http_2.responseText);\n                        }\n                        else {\n                            reject(http_2.status);\n                        }\n                    }\n                };\n                http_2.send(sendable);\n            }\n        });\n    };\n    /* Private methods */\n    LocalRecorder.prototype.onStopDefault = function () {\n        console.log('MediaRecorder stopped  (state=' + this.mediaRecorder.state + ')');\n        this.blob = new Blob(this.chunks, { type: 'video/webm' });\n        this.chunks = [];\n        this.videoPreviewSrc = window.URL.createObjectURL(this.blob);\n        this.state = LocalRecorderState_1.LocalRecorderState.FINISHED;\n    };\n    return LocalRecorder;\n}());\nexports.LocalRecorder = LocalRecorder;\n//# sourceMappingURL=LocalRecorder.js.map"]},"metadata":{},"sourceType":"script"}